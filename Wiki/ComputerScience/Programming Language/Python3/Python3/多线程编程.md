# Python多线程

## GIL(全局解释器锁)

python 中的一个线程对应于 c 语言中的一个线程，前期设计的时候，为了安全，加了一个锁（GIL），加锁的目的就是为了线程安全。

进程是为了管理内存资源，而线程是没有自己的资源的，线程需要取访问进程的资源，当一个线程里存在多个线程，所以多个线程需要共享资源，共享资源的时候就会出现线程不安全的现象，多个线程共同竞争使用进程共享资源时候，就是不安全的；

GIL 锁使得同一时刻只有一个线程运行在一个 cpu 上执行字节码（字节码就是python 编译器生成的），无法将多个线程映射到多个 cpu 去执行；所以 GIL 就无法利用多核的 CPU；

GIL 是会释放的，也就是字节码执行时候，根据字节码执行行数和时间片进行主动释放，在进行 io 操作时候，也会主动释放，不会是绝对安全的；

正是因为遇到 io 操作时候会主动释放，所以在进行 io 操作的时候效率还是非常高的；

### IO 密集程序

对于 IO 密集操作的程序（数据库读写、请求网络资源、读写文件），Python 的多线程是有意义的，而计算密集操作的程序，python 的多线程意义不大；

### 锁 概念

Python 中即使存在 GIL 也是线程不安全的，只能是一定程度上的安全，在 python 代码生成 bytecode 时候，就存在安全问题，所以需要加锁；

两种锁分类：
细粒度锁：程序员主动加锁
粗粒度锁：解释器 GIL 自带，多核 CPU 只能使用 1 核

## 2、python 中多线程编程

对于 io 编程来说，多进程和多线程的区别不大；

## 3、线程间通信：Queue

```python
from Queue import queue

queue.put() # 将变量放入到消息队列中
queue.get() # 获取消息队列中的变量
# 放入和取出是安全的，做过处理
```

## 4、线程同步

多线程编程中两大问题：线程间的通讯和线程同步

用锁的缺点：

- 用锁会影响性能
- 用锁会引起死锁
  - 加锁后出现异常导致没有释放，就会一直卡住
  - 系统资源竞争，会导致操作的时候，出现出现死锁，就是一个锁没有释放，又加上了另一把锁，这就是死循环了
  - 所以安全的锁一定是：加锁-->解锁，中间不能有其他的操作，这样子一定会导致死锁；

RLock：

- 在**同一个线程**中，可以可以连续的调用 RLock.acquire()，但是要有相等数量的 RLock.release()

- 在不同的线程中，这个 RLock 就不起左右了；

## 5、线程池编程

## 6、多进程编程

## 7、进程间通讯

### Lock 线程同步

### RLock 线程同步

### 信号量进行线程同步

### 条件进行线程同步

### 时间进行线程同步

### 同步使用 with 语法（上下文管理器）

## 线程池编程
