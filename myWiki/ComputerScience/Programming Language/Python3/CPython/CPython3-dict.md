#CPython #Python3 #dict



[字典是如何在CPython中实现的？](https://docs.python.org/zh-cn/3/faq/design.html#how-are-dictionaries-implemented-in-cpython)

> CPython的字典实现为可调整大小的哈希表。与B-树相比，这在大多数情况下为查找（目前最常见的操作）提供了更好的性能，并且实现更简单。

> 字典的工作方式是使用 hash() 内置函数计算字典中存储的每个键的hash代码。hash代码根据键和每个进程的种子而变化很大；例如，"Python" 的hash值为-539294296，而"python"(一个按位不同的字符串)的hash值为1142331976。然后，hash代码用于计算内部数组中将存储该值的位置。假设您存储的键都具有不同的hash值，这意味着字典需要恒定的时间 -- O(1)，用Big-O表示法 -- 来检索一个键。



# dict 和 set 实现


字典和集合操作的比较高效，特别是**查找、插入和删除**操作；

这和字典、集合内部的数据结构密不可分。不同于其他数据结构，字典和集合的内部结构都是一张哈希表；

字典：这张表存储了哈希值（hash）、键和值这 3 个元素；
集合：哈希表内没有键和值的配对，只有哈希值（hash）单一的元素；



## dict 实现

### 3.6 版本之前：
3.6 版本之前主要是 dict 内存占用空间大，修改之后会变成有序的 dict，空间也会缩小

dict 内部是一张为 entries 表，这张表结构是`二维数组`，包含了hash、key指针、value指针;

这个二维数组有 8 行，3 列，每个值占用 8 Byte ，所以一列是 24 Byte，初始化就是：192 Byte

```python
my_dict = {}

--+-------------------------------+
  | 哈希值 (hash)  键 (key)  值 (value)
--+-------------------------------+
0 |    hash0      key0    value0
--+-------------------------------+
1 |    hash1      key1    value1
--+-------------------------------+
2 |    hash2      key2    value2
--+-------------------------------+
..|           ...
--+-------------------------------+
7 |    hash7      key7    value7
--+-------------------------------+

```

下图是具体的表现，因为开放寻址的技术，随着 dict 的扩大，这张表格会变得越来越大，越来越稀疏；

```python
entries = [
['--', '--', '--']
[-230273521, 'dob', '1999-01-01'],
['--', '--', '--'],
['--', '--', '--'],
[1231236123, 'name', 'mike'],
['--', '--', '--'],
[9371539127, 'gender', 'male']
]
```

这样造成的后果就是浪费存储空间，而且插入的时候是无序的，顺序是根据 hash 值大小进行排序的，寻址后期就更加无序了，所以需要改进；

### 3.6 版本之后：

现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是下面这样新的结构：

```python
Indices
----------------------------------------------------
None | index | None | None | index | None | index ...
----------------------------------------------------
 
Entries
--------------------
hash0   key0  value0
---------------------
hash1   key1  value1
---------------------
hash2   key2  value2
---------------------
        ...
---------------------
```

会生成两张表，indices（索引） 和 entries（入口）

```python
indices = [None, 1, None, None, 0, None, 2]
entries = [
[1231236123, 'name', 'mike'],
[-230273521, 'dob', '1999-01-01'],
[9371539127, 'gender', 'male']
]
```

entries 是不管任何值的，她就是一个 array，每次创建和插入时候，都会依次进行，这比之前的实现变得更加省内存，同时也是有序的；

indices 其实是 hash 之后的 hash 值，按照算法，得到的值，就是 indices 索引值，会在这个索引插入一个数字，这个数字会按照 entries 的长度确定，比如 entries 长度是 100，也就是有 100 个元素（0--99），所以这个 indices 的值就是 100；查找元素的时候，散列函数计算出一个值，hash(key)，如果是上边的哪个 key，计算的结果是 1000，所以 indices[100]，这个下表的访问是 O(1)，同时得到了一个 

indices 中元素的值对应着 entries 索引，比如 indices 中的 1，就代表 entries[1]，也就是 [-230273521, 'dob', '1999-01-01']





