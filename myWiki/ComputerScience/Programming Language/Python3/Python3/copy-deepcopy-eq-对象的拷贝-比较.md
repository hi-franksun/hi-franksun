# 深拷贝和浅拷贝

Python 中一切皆对象，在对象的操作上，比较和复制都是比较常用的操作；
Python中一切皆对象。对象包含三个要素，id、type、value；
is 是判断identity的，如果两个变量 id (address)相同，那么a is b就是True；
== 是判断 value 的，其实就是 __eq__() 方法，其实 is 要比 == 速度快，因为不需要重载运算符；

所以，比较数值请一定一定用 `==不要用is！`

## 比较

1. `==` 操作符：比较两个对象的值是否相等，也就是两个变量指向的值是否相等；

2. `is` 操作符：对象的身份标示是否相等，也就是指向的是否是同一个对象（同一个内存地址）；

> 变量赋值都会在内存里开辟一个内存，所以理论上除了特殊的，每个变量的 id 都是不同的，指向的是不同的内存；
> 出于对性能优化的考虑，Python 内部会对 -5 到 256 的整型维持一个数组，起到一个缓存的作用。这样，每次你试图创建一个 -5 到 256 范围内的整型数字时，Python 都会从这个数组中返回相对应的引用，而不是重新开辟一块新的内存空间。**整型数字来说，以上a is b为 True 的结论，只适用于 -5 到 256 范围内的数字**
> 你在Pycharm中运行这段代码是属于同一个代码块，如果对代码块的概念不太了解可以去网上查一下。Python出于对性能的考虑，但凡是不可变对象，在同一个代码块中的对象，只有是值相同的对象，就不会重复创建，而是直接引用已经存在的对象
> tuple[[Python3 tuple 实现]] 因为缓冲池的设计,
> 缓冲池只对不可变类型有效，会提高操作效率，可变对象一般都是没有缓冲池概念的，因为经常会变，没必要；

```python
# 字符串或其他
e = '1'  # id=140728435349504
f = '1'  # id=2367577725808
if e is f:
    print('e is f')
else:
    print('e is not f')  # e is f


# 整型，-5 --> 256 缓存机制
a = 12  # id=140728435349504
b = 12  # id=140728435349504
c = 1000  # id=3116661434096
d = 8000  # id=3116661434064

if a is b:
    print('a is b') # a is b
else:
    print("a is not b")

if c is d:
    print('c is d')
else:
    print('c is not d')  # c is not d

# tuple free list 缓冲池机制

tup = (1, )  # 1761560463680
tup1 = (1, )  # 1761560463680
# 这两个 tuple 对象在缓冲机制内，属于同一个内存id

tup2 = (i for i in range(10000))  # 1761560336080
tup3 = (i for i in range(10000))  # 1761561432688
# 超过缓冲池大小，在内存中创建了两个不同大小
```



## 复制

复制分成两种，深拷贝（shallow copy）和浅拷贝（deep copy）