# DQL

## SELECT 数据检索

> SELECT 的作用是从一个表或多个表中检索出想要的数据行；

### limit(约束返回值数量)

一般数据过多，或者只想取若干个数据，这个时候需要使用 limit，limit 需要放在查询语句的最后边；

> **优点**：约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有 1 条，就可以使用LIMIT 1，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。

```sql
select name as '英雄名称', hp_max as '血量高低' from heros order by hp_max limit 5;  // 取出血量最低的 5 个英雄
+----------+----------+
| 英雄名称 | 血量高低 |
+----------+----------+
| 武则天   |     5037 |
| 花木兰   |     5397 |
| 姜子牙   |     5399 |
| 大乔     |     5399 |
| 王昭君   |     5429 |
+----------+----------+
5 rows in set
```

### as(起别名)

有时候原始的数据 column 名字，不太方便阅读，可以使用别名进行输出，更加方便阅读；

```sql
select name as 英雄名字, hp_max as 最大血量 from heros limit 10;
+----------+----------+
| 英雄名字 | 最大血量 |
+----------+----------+
| 夏侯惇   |     7350 |
| 钟无艳   |     7000 |
| 张飞     |     8341 |
| 牛魔     |     8476 |
| 吕布     |     7344 |
| 亚瑟     |     8050 |
| 芈月     |     6164 |
| 程咬金   |     8611 |
| 廉颇     |     9328 |
| 东皇太一 |     7669 |
+----------+----------+
10 rows in set
```

### 查询常数

> 一般使用多表联查

SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。你可能会问为什么我们还要对常数进行查询呢？SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。

```sql
select '王者荣耀' as '平台', name as '英雄名字'  from heros limit 10;
+----------+----------+
| 平台     | 英雄名字 |
+----------+----------+
| 王者荣耀 | 夏侯惇   |
| 王者荣耀 | 钟无艳   |
| 王者荣耀 | 张飞     |
| 王者荣耀 | 牛魔     |
| 王者荣耀 | 吕布     |
| 王者荣耀 | 亚瑟     |
| 王者荣耀 | 芈月     |
| 王者荣耀 | 程咬金   |
| 王者荣耀 | 廉颇     |
| 王者荣耀 | 东皇太一 |
+----------+----------+
10 rows in set
```

> 需要说明的是，如果常数是个字符串，那么使用单引号（‘’）就非常重要了，比如‘王者荣耀’。单引号说明引号中的字符串是个常数，否则 SQL 会把王者荣耀当成列名进行查询，但实际上数据表里没有这个列名，就会引起错误。如果常数是英文字母，比如'WZRY'也需要加引号。如果常数是个数字，就可以直接写数字，不需要单引号，**一般如果使用中文最好都加个单引号**。

### distinct(去除重复行)

使用 `distinct`

DISTINCT 需要放到所有列名的前面，如果写成SELECT name, DISTINCT attack_range FROM heros会报错。
DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 69 条，因为这 69 个英雄名称不同，都有攻击范围（attack_range）这个属性值。如果你想要看都有哪些不同的攻击范围（attack_range），只需要写DISTINCT attack_range即可，后面不需要再加其他的列名了。

```sql
select distinct attack_range as '攻击范围' from heros;
+----------+
| 攻击范围 |
+----------+
| 近战     |
| 远程     |
+----------+
2 rows in set
```

### order by(排序检索数据)

1. 排序的列名：ORDER BY 后面可以有一个或多个列名，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列的值相同的时候，再按照第二列进行排序，以此类推。
2. **排序的顺序**：ORDER BY 后面可以注明排序规则，ASC 代表递增排序，DESC 代表递减排序。如果没有注明排序规则，默认情况下是按照 ASC 递增排序。我们很容易理解 ORDER BY 对数值类型字段的排序规则，但如果排序字段类型为文本数据，就需要参考数据库的设置方式了，这样才能判断 A 是在 B 之前，还是在 B 之后。比如使用 MySQL 在创建字段的时候设置为 BINARY 属性，就代表区分大小写。
3. 非选择列排序：ORDER BY 可以使用非选择列进行排序，所以即使在 SELECT 后面没有这个列名，你同样可以放到 ORDER BY 后面进行排序。
4. ORDER BY 的位置：ORDER BY 通常位于 SELECT 语句的最后一条子句，否则会报错。

```sql
select name as '英雄名称', hp_max as '血量高低' from heros order by hp_max desc limit 10; // 查询出血量最高的 10 个英雄，进行排序，是降序；

+----------+----------+
| 英雄名称 | 血量高低 |
+----------+----------+
| 廉颇     |     9328 |
| 白起     |     8638 |
| 程咬金   |     8611 |
| 刘禅     |     8581 |
| 牛魔     |     8476 |
| 张飞     |     8341 |
| 庄周     |     8149 |
| 刘邦     |     8073 |
| 项羽     |     8057 |
| 亚瑟     |     8050 |
+----------+----------+
10 rows in set
```

## where(数据过滤)

### 比较运算符（字段数值过滤）

比较运算符

| 含义 | 运算符 |
| -- | -- |
| 小于 | < |
| 小于等于 | <= |
| 大于 | > |
| 大于等于 | >= |
| 等于 | = |
| 不等于 | != |
| 之间 | between |
| 空值 | is null |

```sql
mysql> select name as '英雄名称', hp_max as '最大生命值' from heros where hp_max > 8000; // 最大生命值大于 8000
+----------+------------+
| 英雄名称 | 最大生命值 |
+----------+------------+
| 张飞     |       8341 |
| 牛魔     |       8476 |
| 亚瑟     |       8050 |
| 程咬金   |       8611 |
| 廉颇     |       9328 |
| 庄周     |       8149 |
| 白起     |       8638 |
| 刘邦     |       8073 |
| 刘禅     |       8581 |
| 项羽     |       8057 |
+----------+------------+
10 rows in set

select name as '英雄名称', hp_max as '最大生命值' from heros where hp_max between 5000 and 6000; // 最大生命值位于 5000-6000
+----------+------------+
| 英雄名称 | 最大生命值 |
+----------+------------+
| 后羿     |       5986 |
| 马可波罗 |       5584 |
| 鲁班七号 |       5989 |
| 李元芳   |       5725 |
| 黄忠     |       5898 |
| 狄仁杰   |       5710 |
| 虞姬     |       5669 |
| 成吉思汗 |       5799 |
| 嬴政     |       5471 |
| 武则天   |       5037 |
| 甄姬     |       5584 |
| 妲己     |       5824 |
| 干将莫邪 |       5583 |
| 姜子牙   |       5399 |
| 王昭君   |       5429 |
| 诸葛亮   |       5655 |
| 貂蝉     |       5611 |
| 安琪拉   |       5994 |
| 小乔     |       5916 |
| 周瑜     |       5513 |
| 张良     |       5799 |
| 大乔     |       5399 |
| 蔡文姬   |       5910 |
| 花木兰   |       5397 |
| 李白     |       5483 |
| 韩信     |       5655 |
| 阿轲     |       5968 |
| 百里守约 |       5611 |
+----------+------------+
28 rows in set

select name as '英雄名称', hp_max as '最大生命值' from heros where hp_max is null; //最大生命值为空
Empty set
```

### 逻辑运算符（多条件过滤）

一般用来计算多个 where 条件，写一个 where 就可以了；

| 含义 | 逻辑运算符 |
| -- | -- |
| 并且 | and |
| 或者 | or |
| 在指定范围内 | in |
| 非 | not |

> 执行顺序：一般来说 () 优先级最高，其次优先级是 AND，然后是 OR。

```sql
mysql> select name as '英雄名称', hp_max as '最大生命值', mp_max from heros where hp_max > 8000 and mp_max > 1000; // 最大生命值大于 8000且最大法力值大于 1000 的英雄
+----------+------------+--------+
| 英雄名称 | 最大生命值 | mp_max |
+----------+------------+--------+
| 牛魔     |       8476 |   1926 |
| 廉颇     |       9328 |   1708 |
| 庄周     |       8149 |   1694 |
| 白起     |       8638 |   1666 |
| 刘邦     |       8073 |   1940 |
| 刘禅     |       8581 |   1694 |
| 项羽     |       8057 |   1694 |
+----------+------------+--------+
7 rows in set
```

下边是个复杂的查询，注意区分逻辑运算符的先后顺序

```sql
mysql> select name, role_main, role_assist, birthdate from heros
    -> where (role_main in ('法师','射手') or role_assist in ('法师','射手'))
    -> and DATE(birthdate) not between '2016-01-01' and '2017-01-01'
    -> order by (hp_max) desc;
+----------+-----------+-------------+------------+
| name     | role_main | role_assist | birthdate  |
+----------+-----------+-------------+------------+
| 芈月     | 法师      | 坦克        | 2015-12-08 |
| 张良     | 法师      | NULL        | 2015-10-26 |
| 貂蝉     | 法师      | 刺客        | 2015-12-15 |
| 百里守约 | 射手      | 刺客        | 2017-08-08 |
| 干将莫邪 | 法师      | NULL        | 2017-05-22 |
| 周瑜     | 法师      | NULL        | 2015-11-10 |
+----------+-----------+-------------+------------+
6 rows in set
```

### 通配符（复杂过滤）

一般对文本类型 string 进行过滤，使用 like '%孙'/'_孙'

- %：表示若干个字符（包括 0 个），**可以不存在**，比如 '孙%'，既能匹配孙先，又能匹配孙小先，还能匹配：我叫孙小先；
- _：表示一个字符，比如 '孙_'，只能匹配 孙先，不能匹配孙小先；

```sql
select name from heros where name LIKE '%百%';
+----------+
| name     |
+----------+
| 百里守约 |
+----------+
1 row in set
```

> 一般不建议使用通配符进行查询，因为会消耗数据库过多的时间，而且写法上一般使用类似 '鲁%'，而不是 '%班'，因为前者会自动过滤第一位，而后者则会全局查找，消耗较多；


### 分组 group by

比如查询某个班级的平均分、最高分，等这些使用场景的时候，一般会使用分组，然后使用函数进行查询；

根据 team_id 分组查询平均身高；
```sql
select avg(height) from player group by team_id;
+-------------+
| avg(height) |
+-------------+
|    1.987500 |
|    2.000588 |
|    2.240000 |
+-------------+
3 rows in set (0.001 sec)
```

根据 team_id 查询每个队最大的身高(使用了左连接)
```sql
select a.team_id, max(a.height), b.team_name from player as a left join team as b on a.team_id = b.team_id group by team_id;
+---------+---------------+----------------+
| team_id | max(a.height) | team_name      |
+---------+---------------+----------------+
|    1001 |          2.16 | 底特律活塞     |
|    1002 |          2.11 | 印第安纳步行者 |
|    1010 |          2.24 | NULL           |
+---------+---------------+----------------+
```

分组后使用了 having 进行过滤
```sql
MariaDB [sql_test]> select a.team_id, count(a.height), b.team_name from player as a left join team as b on a.team_id = b.team_id group by team_id having a.team_id != 1010;
+---------+-----------------+----------------+
| team_id | count(a.height) | team_name      |
+---------+-----------------+----------------+
|    1001 |              20 | 底特律活塞     |
|    1002 |              17 | 印第安纳步行者 |
+---------+-----------------+----------------+
```

## select 执行顺序

1. 关键字顺序（这个是永远不能改变的）：
    `SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... limit ...`

2. 执行顺序
    `FROM > WHERE > GROUP BY > HAVING > SELECT 的字段 > DISTINCT > ORDER BY > LIMIT`

    ```sql
    SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5
    FROM player JOIN team ON player.team_id = team.team_id # 顺序 1
    WHERE height > 1.80 # 顺序 2
    GROUP BY player.team_id # 顺序 3
    HAVING num > 2 # 顺序 4
    ORDER BY num DESC # 顺序 6
    LIMIT 2 # 顺序 7
    ```

### 具体执行顺序

1. FROM 阶段--> vt0
    在这个阶段，如果是多张表联查，还会经历下面的几个步骤：
    - 首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；
    - 通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；
    - 添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。
    - 当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。
    - 最后我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1

2. WHERE 阶段（数据过滤）--> vt1

3. GROUP 阶段--> vt2

4. HAVING 阶段（数据过滤）--> vt3

5. SELECT 和 DISTINCT 阶段--> vt4

6. ORDER BY 阶段--> vt5
  按照指定的字段进行排序

7. LIMIT 阶段（limit=1 意味着查询到 1 个就会返回，不会继续查询了）--> vt6
  最后的阶段，

> 在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。

## select 优化

- 不要使用 select * ，查询结果过多，传输过程中会占用 IO
- 善于使用 limit，减少查询结果，减少传输过程 IO 消耗和查询过程需要遍历所有表格；
- 增加数据过滤，避免传输不必要的数据，增加 IO


## SQL function

大概分成四类内置函数

1. 算术函数：算术处理

    | 函数 | 定义 | 实例 |
    | -- | -- | -- |
    | abs() | 取绝对值 | ads(-2) = 2 |
    | mod() | 取余 | mod(100, 3) = 1 |
    | round() | 对数据进行四舍五入处理 | round(1.23, 1) = 1.2 |


2. 字符串函数：字符串处理

    | 函数 | 定义 | 实例 |
    | -- | -- | -- |
    | concat() | 多个字符串拼接 |concat('abc', 123) =   abc123|
    | length() | 计算字符串长度，一个汉字 3 个字符，数字和字符算 1 个字符| length('你好') = 6|
    | char_length() | 计算字段长度，汉字、数字、字母都算一个 |char_length('abc') = 3|
    | lower() | 转成小写 | lower('ABC') = abc |
    | upper() | 转成大写 | upper('abc') = ABC|
    | replace() | 替换字符串，接收三个参数，| replace('fabcd', 'abc', 123) = 'f123d'|
    | substring | 截取字符串，接收三个参数 | substring('abcde', 1, 3) = abc |

3. 日期函数：日期处理

    | 函数 | 定义 | 实例 |
    | -- | -- | -- |
    | current_date | 返回当前日期 | current_date() = 2020-09-22 |
    | date() | 返回当前日期的字符串 | date('2020-09-02 11:00:00') = 2020-09-02 |
    > 日期比较要使用 date() 函数，因为不知道日记到底是 datetime 类型，还是 string 类型

4. 转换函数：数据类型转换
    实际开发种几乎不用，

5. 聚集函数（最常用的是和分组相关，比如分组计算/过滤）
    | 函数 | 定义 | 实例 |
    | -- | -- | -- |
    | count() | 计算总行数 | |
    | max() | 取最大值 | |
    | min() | 取最小值 | |
    | sum() | 计算和 | |
    | avg() | 计算平均数 | |

    ```sql
    SELECT COUNT(*), AVG(hp_max), MAX(mp_max), MIN(attack_max), SUM(defense_max) FROM heros WHERE role_main = '射手' or role_assist = '射手'
    ;
    +----------+-------------+-------------+-----------------+------------------+
    | COUNT(*) | AVG(hp_max) | MAX(mp_max) | MIN(attack_max) | SUM(defense_max) |
    +----------+-------------+-------------+-----------------+------------------+
    |       10 |      5798.5 |        1784 |             362 |             3333 |
    +----------+-------------+-------------+-----------------+------------------+
    ```

### 常见的使用方法

```sql
select name, max(hp_max) from heros; //返回血量最大值
+--------+-------------+
| name   | max(hp_max) |
+--------+-------------+
| 夏侯惇 |        9328 |
+--------+-------------+
```

```sql
select name, round(hp_max, 1) from heros limit 5;//将血量进行处理，增加了一位小数
+--------+------------------+
| name   | round(hp_max, 1) |
+--------+------------------+
| 夏侯惇 |           7350.0 |
| 钟无艳 |           7000.0 |
| 张飞   |           8341.0 |
| 牛魔   |           8476.0 |
| 吕布   |           7344.0 |
+--------+------------------+
5 rows in set
```

```sql
select char_length(name) as name_length, name from heros order by name_length desc limit 5; //找出名字长度最长的前 5 个（限制5个是为了笔记，不是排序）
+-------------+----------+
| name_length | name     |
+-------------+----------+
|           4 | 百里守约 |
|           4 | 鲁班七号 |
|           4 | 成吉思汗 |
|           4 | 东皇太一 |
|           4 | 太乙真人 |
+-------------+----------+
5 rows in set

```

### 使用函数存在问题

它会导致查询不走索引，直接全表遍历，导致慢查询-这才是最重要的问题。现实工作中一般是禁止 where 条件出现函数：看到了就让开发代码重写。


## 子查询

0. 非关联子查询
一般子查询和主查询都是同一张表的时候，且子查询出来的表直接给主查询使用了，一般不会涉及两张表，叫做非关联子查询

比如想知道某个球员是最高的，并输出姓名和身高，这个可以进行拆解，先得到最高的身高，然后条件过滤查询即可；

如果不使用子查询，想当然的使用以下的查询，肯定是错误的！
```sql
> select player_name, height, max(height)
-> from player;
+-------------+--------+-------------+
| player_name | height | max(height) |
+-------------+--------+-------------+
| 韦恩-艾灵顿 |   1.93 |        2.24 |
+-------------+--------+-------------+
```

正确的写法是先通过子查询，查出最高的身高值，再进行条件过滤查询

```sql
> select player_name, height
-> from player
-> where height =
-> (select max(height) from player);
+-------------+--------+
| player_name | height |
+-------------+--------+
| 奥尼尔      |   2.24 |
+-------------+--------+
1 row in set (0.001 sec)
```

1. 关联子查询
如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。


### 子查询中的关键字

exist(常用)
in(常用)

也就是子查询出来一个结果，然后主查询将子查询的结果作为过滤条件，看是否 exist/in 在子查询的结果中，属于关联子查询这一类，不仅会使用 exist/in，还会使用 not exist/in

> exist 和 in 区别：看主表和从表哪个大来确定使用哪个，

any(some)
all

